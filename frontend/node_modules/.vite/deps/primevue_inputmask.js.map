{
  "version": 3,
  "sources": ["../../src/inputmask/style/InputMaskStyle.js", "../../src/inputmask/BaseInputMask.vue", "../../src/inputmask/InputMask.vue", "../../src/inputmask/InputMask.vue?vue&type=template&id=d0e11c90&lang.js"],
  "sourcesContent": ["import BaseStyle from '@primevue/core/base/style';\n\nconst classes = {\n    root: ({ instance }) => [\n        'p-inputmask',\n        {\n            'p-filled': instance.filled\n        }\n    ]\n};\n\nexport default BaseStyle.extend({\n    name: 'inputmask',\n    classes\n});\n", "<script>\nimport BaseComponent from '@primevue/core/basecomponent';\nimport InputMaskStyle from 'primevue/inputmask/style';\n\nexport default {\n    name: 'BaseInputMask',\n    extends: BaseComponent,\n    props: {\n        modelValue: null,\n        slotChar: {\n            type: String,\n            default: '_'\n        },\n        id: {\n            type: String,\n            default: null\n        },\n        class: {\n            type: [String, Object],\n            default: null\n        },\n        mask: {\n            type: String,\n            default: null\n        },\n        placeholder: {\n            type: String,\n            default: null\n        },\n        autoClear: {\n            type: Boolean,\n            default: true\n        },\n        unmask: {\n            type: Boolean,\n            default: false\n        },\n        readonly: {\n            type: Boolean,\n            default: false\n        },\n        invalid: {\n            type: Boolean,\n            default: false\n        },\n        disabled: {\n            type: Boolean,\n            default: false\n        },\n        name: {\n            type: String,\n            default: null\n        },\n        variant: {\n            type: String,\n            default: null\n        },\n        fluid: {\n            type: Boolean,\n            default: null\n        }\n    },\n    style: InputMaskStyle,\n    provide() {\n        return {\n            $pcInputMask: this,\n            $parentInstance: this\n        };\n    }\n};\n</script>\n", "<template>\n    <InputText\n        :id=\"id\"\n        :value=\"currentVal\"\n        :class=\"inputClass\"\n        :readonly=\"readonly\"\n        :disabled=\"disabled\"\n        :invalid=\"invalid\"\n        :name=\"name\"\n        :variant=\"variant\"\n        :placeholder=\"placeholder\"\n        :fluid=\"hasFluid\"\n        :unstyled=\"unstyled\"\n        @input=\"onInput\"\n        @compositionend=\"onInput\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"\n        @keydown=\"onKeyDown\"\n        @keypress=\"onKeyPress\"\n        @paste=\"onPaste\"\n        :pt=\"rootPTOptions\"\n    />\n</template>\n\n<script>\nimport { getUserAgent } from '@primeuix/utils/dom';\nimport { isEmpty } from '@primeuix/utils/object';\nimport InputText from 'primevue/inputtext';\nimport { mergeProps } from 'vue';\nimport BaseInputMask from './BaseInputMask.vue';\n\nexport default {\n    name: 'InputMask',\n    extends: BaseInputMask,\n    inheritAttrs: false,\n    emits: ['update:modelValue', 'focus', 'blur', 'keydown', 'complete', 'keypress', 'paste'],\n    inject: {\n        $pcFluid: { default: null }\n    },\n    data() {\n        return {\n            currentVal: ''\n        };\n    },\n    watch: {\n        mask(newMask, oldMask) {\n            if (oldMask !== newMask) {\n                this.initMask();\n            }\n        }\n    },\n    mounted() {\n        this.initMask();\n    },\n    updated() {\n        if (this.isValueUpdated()) {\n            this.updateValue();\n        }\n    },\n    methods: {\n        onInput(event) {\n            // Check if the event is part of a text composition process (e.g., for Asian languages).\n            // If event.isComposing is true, it means the user is still composing text and the input is not finalized.\n            if (!event.isComposing) {\n                if (this.androidChrome) this.handleAndroidInput(event);\n                else this.handleInputChange(event);\n\n                this.updateModelValue(event.target.value);\n            }\n        },\n        onFocus(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            this.focus = true;\n\n            clearTimeout(this.caretTimeoutId);\n            let pos;\n\n            this.focusText = this.$el.value;\n\n            pos = this.checkVal();\n\n            this.caretTimeoutId = setTimeout(() => {\n                if (this.$el !== document.activeElement) {\n                    return;\n                }\n\n                this.writeBuffer();\n\n                if (pos === this.mask.replace('?', '').length) {\n                    this.caret(0, pos);\n                } else {\n                    this.caret(pos);\n                }\n            }, 10);\n\n            this.$emit('focus', event);\n        },\n        onBlur(event) {\n            this.focus = false;\n            this.checkVal();\n            this.updateModelValue(event.target.value);\n\n            if (this.$el.value !== this.focusText) {\n                let e = document.createEvent('HTMLEvents');\n\n                e.initEvent('change', true, false);\n                this.$el.dispatchEvent(e);\n            }\n\n            this.$emit('blur', event);\n        },\n        onKeyDown(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            let k = event.code,\n                pos,\n                begin,\n                end;\n            let iPhone = /iphone/i.test(getUserAgent());\n\n            this.oldVal = this.$el.value;\n\n            //backspace, delete, and escape get special treatment\n            if (k === 'Backspace' || k === 'Delete' || (iPhone && k === 'Escape')) {\n                pos = this.caret();\n                begin = pos.begin;\n                end = pos.end;\n\n                if (end - begin === 0) {\n                    begin = k !== 'Delete' ? this.seekPrev(begin) : (end = this.seekNext(begin - 1));\n                    end = k === 'Delete' ? this.seekNext(end) : end;\n                }\n\n                this.clearBuffer(begin, end);\n                this.shiftL(begin, end - 1);\n                this.updateModelValue(event.target.value);\n\n                event.preventDefault();\n            } else if (k === 'Enter') {\n                // enter\n                this.$el.blur();\n                this.updateModelValue(event.target.value);\n            } else if (k === 'Escape') {\n                // escape\n                this.$el.value = this.focusText;\n                this.caret(0, this.checkVal());\n                this.updateModelValue(event.target.value);\n                event.preventDefault();\n            }\n\n            this.$emit('keydown', event);\n        },\n        onKeyPress(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            var k = event.code,\n                pos = this.caret(),\n                p,\n                c,\n                next,\n                completed;\n\n            if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey || event.key === 'CapsLock' || event.key === 'Escape' || event.key === 'Tab') {\n                //Ignore\n                return;\n            } else if (k && k !== 'Enter') {\n                if (pos.end - pos.begin !== 0) {\n                    this.clearBuffer(pos.begin, pos.end);\n                    this.shiftL(pos.begin, pos.end - 1);\n                }\n\n                p = this.seekNext(pos.begin - 1);\n\n                if (p < this.len) {\n                    c = event.key;\n\n                    if (this.tests[p].test(c)) {\n                        this.shiftR(p);\n\n                        this.buffer[p] = c;\n                        this.writeBuffer();\n                        next = this.seekNext(p);\n\n                        if (/android/i.test(getUserAgent())) {\n                            //Path for CSP Violation on FireFox OS 1.1\n                            let proxy = () => {\n                                this.caret(next);\n                            };\n\n                            setTimeout(proxy, 0);\n                        } else {\n                            this.caret(next);\n                        }\n\n                        if (pos.begin <= this.lastRequiredNonMaskPos) {\n                            completed = this.isCompleted();\n                        }\n                    }\n                }\n\n                event.preventDefault();\n            }\n\n            this.updateModelValue(event.target.value);\n\n            if (completed) {\n                this.$emit('complete', event);\n            }\n\n            this.$emit('keypress', event);\n        },\n        onPaste(event) {\n            this.handleInputChange(event);\n\n            this.$emit('paste', event);\n        },\n        caret(first, last) {\n            let range, begin, end;\n\n            if (!this.$el.offsetParent || this.$el !== document.activeElement) {\n                return;\n            }\n\n            if (typeof first === 'number') {\n                begin = first;\n                end = typeof last === 'number' ? last : begin;\n\n                if (this.$el.setSelectionRange) {\n                    this.$el.setSelectionRange(begin, end);\n                } else if (this.$el['createTextRange']) {\n                    range = this.$el['createTextRange']();\n                    range.collapse(true);\n                    range.moveEnd('character', end);\n                    range.moveStart('character', begin);\n                    range.select();\n                }\n            } else {\n                if (this.$el.setSelectionRange) {\n                    begin = this.$el.selectionStart;\n                    end = this.$el.selectionEnd;\n                } else if (document['selection'] && document['selection'].createRange) {\n                    range = document['selection'].createRange();\n                    begin = 0 - range.duplicate().moveStart('character', -100000);\n                    end = begin + range.text.length;\n                }\n\n                return { begin: begin, end: end };\n            }\n        },\n        isCompleted() {\n            for (let i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {\n                if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n        getPlaceholder(i) {\n            if (i < this.slotChar.length) {\n                return this.slotChar.charAt(i);\n            }\n\n            return this.slotChar.charAt(0);\n        },\n        seekNext(pos) {\n            while (++pos < this.len && !this.tests[pos]);\n\n            return pos;\n        },\n        seekPrev(pos) {\n            while (--pos >= 0 && !this.tests[pos]);\n\n            return pos;\n        },\n        shiftL(begin, end) {\n            let i, j;\n\n            if (begin < 0) {\n                return;\n            }\n\n            for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n                if (this.tests[i]) {\n                    if (j < this.len && this.tests[i].test(this.buffer[j])) {\n                        this.buffer[i] = this.buffer[j];\n                        this.buffer[j] = this.getPlaceholder(j);\n                    } else {\n                        break;\n                    }\n\n                    j = this.seekNext(j);\n                }\n            }\n\n            this.writeBuffer();\n            this.caret(Math.max(this.firstNonMaskPos, begin));\n        },\n        shiftR(pos) {\n            let i, c, j, t;\n\n            for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n                if (this.tests[i]) {\n                    j = this.seekNext(i);\n                    t = this.buffer[i];\n                    this.buffer[i] = c;\n\n                    if (j < this.len && this.tests[j].test(t)) {\n                        c = t;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        },\n        handleAndroidInput(event) {\n            var curVal = this.$el.value;\n            var pos = this.caret();\n\n            if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n                // a deletion or backspace happened\n                this.checkVal(true);\n                while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n\n                if (pos.begin === 0) {\n                    while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n                }\n\n                this.caret(pos.begin, pos.begin);\n            } else {\n                this.checkVal(true);\n                while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n\n                this.caret(pos.begin, pos.begin);\n            }\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        clearBuffer(start, end) {\n            let i;\n\n            for (i = start; i < end && i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n                }\n            }\n        },\n        writeBuffer() {\n            this.$el.value = this.buffer.join('');\n        },\n        checkVal(allow) {\n            this.isValueChecked = true;\n            //try to place characters where they belong\n            let test = this.$el.value,\n                lastMatch = -1,\n                i,\n                c,\n                pos;\n\n            for (i = 0, pos = 0; i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n\n                    while (pos++ < test.length) {\n                        c = test.charAt(pos - 1);\n\n                        if (this.tests[i].test(c)) {\n                            this.buffer[i] = c;\n                            lastMatch = i;\n                            break;\n                        }\n                    }\n\n                    if (pos > test.length) {\n                        this.clearBuffer(i + 1, this.len);\n                        break;\n                    }\n                } else {\n                    if (this.buffer[i] === test.charAt(pos)) {\n                        pos++;\n                    }\n\n                    if (i < this.partialPosition) {\n                        lastMatch = i;\n                    }\n                }\n            }\n\n            if (allow) {\n                this.writeBuffer();\n            } else if (lastMatch + 1 < this.partialPosition) {\n                if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n                    // Invalid value. Remove it and replace it with the\n                    // mask, which is the default behavior.\n                    if (this.$el.value) this.$el.value = '';\n                    this.clearBuffer(0, this.len);\n                } else {\n                    // Invalid value, but we opt to show the value to the\n                    // user and allow them to correct their mistake.\n                    this.writeBuffer();\n                }\n            } else {\n                this.writeBuffer();\n                this.$el.value = this.$el.value.substring(0, lastMatch + 1);\n            }\n\n            return this.partialPosition ? i : this.firstNonMaskPos;\n        },\n        handleInputChange(event) {\n            const isPasteEvent = event.type === 'paste';\n\n            if (this.readonly || isPasteEvent) {\n                return;\n            }\n\n            var pos = this.checkVal(true);\n\n            this.caret(pos);\n            this.updateModelValue(event.target.value);\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        getUnmaskedValue() {\n            let unmaskedBuffer = [];\n\n            for (let i = 0; i < this.buffer.length; i++) {\n                let c = this.buffer[i];\n\n                if (this.tests[i] && c !== this.getPlaceholder(i)) {\n                    unmaskedBuffer.push(c);\n                }\n            }\n\n            return unmaskedBuffer.join('');\n        },\n\n        updateModelValue(value) {\n            const val = this.unmask ? this.getUnmaskedValue() : value;\n\n            this.currentVal = value;\n\n            this.$emit('update:modelValue', this.defaultBuffer !== val ? val : '');\n        },\n        updateValue(updateModel = true) {\n            if (this.$el) {\n                if (this.modelValue == null) {\n                    this.$el.value = '';\n                    updateModel && this.updateModelValue('');\n                } else {\n                    this.$el.value = this.modelValue;\n                    this.checkVal();\n\n                    setTimeout(() => {\n                        if (this.$el) {\n                            this.writeBuffer();\n                            this.checkVal();\n\n                            if (updateModel) this.updateModelValue(this.$el.value);\n                        }\n                    }, 10);\n                }\n\n                this.focusText = this.$el.value;\n            }\n        },\n        initMask() {\n            this.tests = [];\n            this.partialPosition = this.mask.length;\n            this.len = this.mask.length;\n            this.firstNonMaskPos = null;\n            this.defs = {\n                9: '[0-9]',\n                a: '[A-Za-z]',\n                '*': '[A-Za-z0-9]'\n            };\n\n            let ua = getUserAgent();\n\n            this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);\n\n            let maskTokens = this.mask.split('');\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c === '?') {\n                    this.len--;\n                    this.partialPosition = i;\n                } else if (this.defs[c]) {\n                    this.tests.push(new RegExp(this.defs[c]));\n\n                    if (this.firstNonMaskPos === null) {\n                        this.firstNonMaskPos = this.tests.length - 1;\n                    }\n\n                    if (i < this.partialPosition) {\n                        this.lastRequiredNonMaskPos = this.tests.length - 1;\n                    }\n                } else {\n                    this.tests.push(null);\n                }\n            }\n\n            this.buffer = [];\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c !== '?') {\n                    if (this.defs[c]) this.buffer.push(this.getPlaceholder(i));\n                    else this.buffer.push(c);\n                }\n            }\n\n            this.defaultBuffer = this.buffer.join('');\n            this.updateValue(false);\n        },\n        isValueUpdated() {\n            return this.unmask ? this.modelValue != this.getUnmaskedValue() : this.defaultBuffer !== this.$el.value && this.$el.value !== this.modelValue;\n        }\n    },\n    computed: {\n        filled() {\n            return this.modelValue != null && this.modelValue.toString().length > 0;\n        },\n        inputClass() {\n            return [this.cx('root'), this.class];\n        },\n        rootPTOptions() {\n            return {\n                root: mergeProps(this.ptm('pcInputText', this.ptmParams), this.ptmi('root', this.ptmParams))\n            };\n        },\n        ptmParams() {\n            return {\n                context: {\n                    filled: this.filled\n                }\n            };\n        },\n        hasFluid() {\n            return isEmpty(this.fluid) ? !!this.$pcFluid : this.fluid;\n        }\n    },\n    components: {\n        InputText\n    }\n};\n</script>\n", "<template>\n    <InputText\n        :id=\"id\"\n        :value=\"currentVal\"\n        :class=\"inputClass\"\n        :readonly=\"readonly\"\n        :disabled=\"disabled\"\n        :invalid=\"invalid\"\n        :name=\"name\"\n        :variant=\"variant\"\n        :placeholder=\"placeholder\"\n        :fluid=\"hasFluid\"\n        :unstyled=\"unstyled\"\n        @input=\"onInput\"\n        @compositionend=\"onInput\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"\n        @keydown=\"onKeyDown\"\n        @keypress=\"onKeyPress\"\n        @paste=\"onPaste\"\n        :pt=\"rootPTOptions\"\n    />\n</template>\n\n<script>\nimport { getUserAgent } from '@primeuix/utils/dom';\nimport { isEmpty } from '@primeuix/utils/object';\nimport InputText from 'primevue/inputtext';\nimport { mergeProps } from 'vue';\nimport BaseInputMask from './BaseInputMask.vue';\n\nexport default {\n    name: 'InputMask',\n    extends: BaseInputMask,\n    inheritAttrs: false,\n    emits: ['update:modelValue', 'focus', 'blur', 'keydown', 'complete', 'keypress', 'paste'],\n    inject: {\n        $pcFluid: { default: null }\n    },\n    data() {\n        return {\n            currentVal: ''\n        };\n    },\n    watch: {\n        mask(newMask, oldMask) {\n            if (oldMask !== newMask) {\n                this.initMask();\n            }\n        }\n    },\n    mounted() {\n        this.initMask();\n    },\n    updated() {\n        if (this.isValueUpdated()) {\n            this.updateValue();\n        }\n    },\n    methods: {\n        onInput(event) {\n            // Check if the event is part of a text composition process (e.g., for Asian languages).\n            // If event.isComposing is true, it means the user is still composing text and the input is not finalized.\n            if (!event.isComposing) {\n                if (this.androidChrome) this.handleAndroidInput(event);\n                else this.handleInputChange(event);\n\n                this.updateModelValue(event.target.value);\n            }\n        },\n        onFocus(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            this.focus = true;\n\n            clearTimeout(this.caretTimeoutId);\n            let pos;\n\n            this.focusText = this.$el.value;\n\n            pos = this.checkVal();\n\n            this.caretTimeoutId = setTimeout(() => {\n                if (this.$el !== document.activeElement) {\n                    return;\n                }\n\n                this.writeBuffer();\n\n                if (pos === this.mask.replace('?', '').length) {\n                    this.caret(0, pos);\n                } else {\n                    this.caret(pos);\n                }\n            }, 10);\n\n            this.$emit('focus', event);\n        },\n        onBlur(event) {\n            this.focus = false;\n            this.checkVal();\n            this.updateModelValue(event.target.value);\n\n            if (this.$el.value !== this.focusText) {\n                let e = document.createEvent('HTMLEvents');\n\n                e.initEvent('change', true, false);\n                this.$el.dispatchEvent(e);\n            }\n\n            this.$emit('blur', event);\n        },\n        onKeyDown(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            let k = event.code,\n                pos,\n                begin,\n                end;\n            let iPhone = /iphone/i.test(getUserAgent());\n\n            this.oldVal = this.$el.value;\n\n            //backspace, delete, and escape get special treatment\n            if (k === 'Backspace' || k === 'Delete' || (iPhone && k === 'Escape')) {\n                pos = this.caret();\n                begin = pos.begin;\n                end = pos.end;\n\n                if (end - begin === 0) {\n                    begin = k !== 'Delete' ? this.seekPrev(begin) : (end = this.seekNext(begin - 1));\n                    end = k === 'Delete' ? this.seekNext(end) : end;\n                }\n\n                this.clearBuffer(begin, end);\n                this.shiftL(begin, end - 1);\n                this.updateModelValue(event.target.value);\n\n                event.preventDefault();\n            } else if (k === 'Enter') {\n                // enter\n                this.$el.blur();\n                this.updateModelValue(event.target.value);\n            } else if (k === 'Escape') {\n                // escape\n                this.$el.value = this.focusText;\n                this.caret(0, this.checkVal());\n                this.updateModelValue(event.target.value);\n                event.preventDefault();\n            }\n\n            this.$emit('keydown', event);\n        },\n        onKeyPress(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            var k = event.code,\n                pos = this.caret(),\n                p,\n                c,\n                next,\n                completed;\n\n            if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey || event.key === 'CapsLock' || event.key === 'Escape' || event.key === 'Tab') {\n                //Ignore\n                return;\n            } else if (k && k !== 'Enter') {\n                if (pos.end - pos.begin !== 0) {\n                    this.clearBuffer(pos.begin, pos.end);\n                    this.shiftL(pos.begin, pos.end - 1);\n                }\n\n                p = this.seekNext(pos.begin - 1);\n\n                if (p < this.len) {\n                    c = event.key;\n\n                    if (this.tests[p].test(c)) {\n                        this.shiftR(p);\n\n                        this.buffer[p] = c;\n                        this.writeBuffer();\n                        next = this.seekNext(p);\n\n                        if (/android/i.test(getUserAgent())) {\n                            //Path for CSP Violation on FireFox OS 1.1\n                            let proxy = () => {\n                                this.caret(next);\n                            };\n\n                            setTimeout(proxy, 0);\n                        } else {\n                            this.caret(next);\n                        }\n\n                        if (pos.begin <= this.lastRequiredNonMaskPos) {\n                            completed = this.isCompleted();\n                        }\n                    }\n                }\n\n                event.preventDefault();\n            }\n\n            this.updateModelValue(event.target.value);\n\n            if (completed) {\n                this.$emit('complete', event);\n            }\n\n            this.$emit('keypress', event);\n        },\n        onPaste(event) {\n            this.handleInputChange(event);\n\n            this.$emit('paste', event);\n        },\n        caret(first, last) {\n            let range, begin, end;\n\n            if (!this.$el.offsetParent || this.$el !== document.activeElement) {\n                return;\n            }\n\n            if (typeof first === 'number') {\n                begin = first;\n                end = typeof last === 'number' ? last : begin;\n\n                if (this.$el.setSelectionRange) {\n                    this.$el.setSelectionRange(begin, end);\n                } else if (this.$el['createTextRange']) {\n                    range = this.$el['createTextRange']();\n                    range.collapse(true);\n                    range.moveEnd('character', end);\n                    range.moveStart('character', begin);\n                    range.select();\n                }\n            } else {\n                if (this.$el.setSelectionRange) {\n                    begin = this.$el.selectionStart;\n                    end = this.$el.selectionEnd;\n                } else if (document['selection'] && document['selection'].createRange) {\n                    range = document['selection'].createRange();\n                    begin = 0 - range.duplicate().moveStart('character', -100000);\n                    end = begin + range.text.length;\n                }\n\n                return { begin: begin, end: end };\n            }\n        },\n        isCompleted() {\n            for (let i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {\n                if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n        getPlaceholder(i) {\n            if (i < this.slotChar.length) {\n                return this.slotChar.charAt(i);\n            }\n\n            return this.slotChar.charAt(0);\n        },\n        seekNext(pos) {\n            while (++pos < this.len && !this.tests[pos]);\n\n            return pos;\n        },\n        seekPrev(pos) {\n            while (--pos >= 0 && !this.tests[pos]);\n\n            return pos;\n        },\n        shiftL(begin, end) {\n            let i, j;\n\n            if (begin < 0) {\n                return;\n            }\n\n            for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n                if (this.tests[i]) {\n                    if (j < this.len && this.tests[i].test(this.buffer[j])) {\n                        this.buffer[i] = this.buffer[j];\n                        this.buffer[j] = this.getPlaceholder(j);\n                    } else {\n                        break;\n                    }\n\n                    j = this.seekNext(j);\n                }\n            }\n\n            this.writeBuffer();\n            this.caret(Math.max(this.firstNonMaskPos, begin));\n        },\n        shiftR(pos) {\n            let i, c, j, t;\n\n            for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n                if (this.tests[i]) {\n                    j = this.seekNext(i);\n                    t = this.buffer[i];\n                    this.buffer[i] = c;\n\n                    if (j < this.len && this.tests[j].test(t)) {\n                        c = t;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        },\n        handleAndroidInput(event) {\n            var curVal = this.$el.value;\n            var pos = this.caret();\n\n            if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n                // a deletion or backspace happened\n                this.checkVal(true);\n                while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n\n                if (pos.begin === 0) {\n                    while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n                }\n\n                this.caret(pos.begin, pos.begin);\n            } else {\n                this.checkVal(true);\n                while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n\n                this.caret(pos.begin, pos.begin);\n            }\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        clearBuffer(start, end) {\n            let i;\n\n            for (i = start; i < end && i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n                }\n            }\n        },\n        writeBuffer() {\n            this.$el.value = this.buffer.join('');\n        },\n        checkVal(allow) {\n            this.isValueChecked = true;\n            //try to place characters where they belong\n            let test = this.$el.value,\n                lastMatch = -1,\n                i,\n                c,\n                pos;\n\n            for (i = 0, pos = 0; i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n\n                    while (pos++ < test.length) {\n                        c = test.charAt(pos - 1);\n\n                        if (this.tests[i].test(c)) {\n                            this.buffer[i] = c;\n                            lastMatch = i;\n                            break;\n                        }\n                    }\n\n                    if (pos > test.length) {\n                        this.clearBuffer(i + 1, this.len);\n                        break;\n                    }\n                } else {\n                    if (this.buffer[i] === test.charAt(pos)) {\n                        pos++;\n                    }\n\n                    if (i < this.partialPosition) {\n                        lastMatch = i;\n                    }\n                }\n            }\n\n            if (allow) {\n                this.writeBuffer();\n            } else if (lastMatch + 1 < this.partialPosition) {\n                if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n                    // Invalid value. Remove it and replace it with the\n                    // mask, which is the default behavior.\n                    if (this.$el.value) this.$el.value = '';\n                    this.clearBuffer(0, this.len);\n                } else {\n                    // Invalid value, but we opt to show the value to the\n                    // user and allow them to correct their mistake.\n                    this.writeBuffer();\n                }\n            } else {\n                this.writeBuffer();\n                this.$el.value = this.$el.value.substring(0, lastMatch + 1);\n            }\n\n            return this.partialPosition ? i : this.firstNonMaskPos;\n        },\n        handleInputChange(event) {\n            const isPasteEvent = event.type === 'paste';\n\n            if (this.readonly || isPasteEvent) {\n                return;\n            }\n\n            var pos = this.checkVal(true);\n\n            this.caret(pos);\n            this.updateModelValue(event.target.value);\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        getUnmaskedValue() {\n            let unmaskedBuffer = [];\n\n            for (let i = 0; i < this.buffer.length; i++) {\n                let c = this.buffer[i];\n\n                if (this.tests[i] && c !== this.getPlaceholder(i)) {\n                    unmaskedBuffer.push(c);\n                }\n            }\n\n            return unmaskedBuffer.join('');\n        },\n\n        updateModelValue(value) {\n            const val = this.unmask ? this.getUnmaskedValue() : value;\n\n            this.currentVal = value;\n\n            this.$emit('update:modelValue', this.defaultBuffer !== val ? val : '');\n        },\n        updateValue(updateModel = true) {\n            if (this.$el) {\n                if (this.modelValue == null) {\n                    this.$el.value = '';\n                    updateModel && this.updateModelValue('');\n                } else {\n                    this.$el.value = this.modelValue;\n                    this.checkVal();\n\n                    setTimeout(() => {\n                        if (this.$el) {\n                            this.writeBuffer();\n                            this.checkVal();\n\n                            if (updateModel) this.updateModelValue(this.$el.value);\n                        }\n                    }, 10);\n                }\n\n                this.focusText = this.$el.value;\n            }\n        },\n        initMask() {\n            this.tests = [];\n            this.partialPosition = this.mask.length;\n            this.len = this.mask.length;\n            this.firstNonMaskPos = null;\n            this.defs = {\n                9: '[0-9]',\n                a: '[A-Za-z]',\n                '*': '[A-Za-z0-9]'\n            };\n\n            let ua = getUserAgent();\n\n            this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);\n\n            let maskTokens = this.mask.split('');\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c === '?') {\n                    this.len--;\n                    this.partialPosition = i;\n                } else if (this.defs[c]) {\n                    this.tests.push(new RegExp(this.defs[c]));\n\n                    if (this.firstNonMaskPos === null) {\n                        this.firstNonMaskPos = this.tests.length - 1;\n                    }\n\n                    if (i < this.partialPosition) {\n                        this.lastRequiredNonMaskPos = this.tests.length - 1;\n                    }\n                } else {\n                    this.tests.push(null);\n                }\n            }\n\n            this.buffer = [];\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c !== '?') {\n                    if (this.defs[c]) this.buffer.push(this.getPlaceholder(i));\n                    else this.buffer.push(c);\n                }\n            }\n\n            this.defaultBuffer = this.buffer.join('');\n            this.updateValue(false);\n        },\n        isValueUpdated() {\n            return this.unmask ? this.modelValue != this.getUnmaskedValue() : this.defaultBuffer !== this.$el.value && this.$el.value !== this.modelValue;\n        }\n    },\n    computed: {\n        filled() {\n            return this.modelValue != null && this.modelValue.toString().length > 0;\n        },\n        inputClass() {\n            return [this.cx('root'), this.class];\n        },\n        rootPTOptions() {\n            return {\n                root: mergeProps(this.ptm('pcInputText', this.ptmParams), this.ptmi('root', this.ptmParams))\n            };\n        },\n        ptmParams() {\n            return {\n                context: {\n                    filled: this.filled\n                }\n            };\n        },\n        hasFluid() {\n            return isEmpty(this.fluid) ? !!this.$pcFluid : this.fluid;\n        }\n    },\n    components: {\n        InputText\n    }\n};\n</script>\n"],
  "mappings": "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",
  "names": ["classes", "root", "_ref", "instance", "filled", "BaseStyle", "extend", "name", "name", "BaseComponent", "props", "modelValue", "slotChar", "type", "String", "id", "Object", "mask", "placeholder", "autoClear", "Boolean", "unmask", "readonly", "invalid", "disabled", "variant", "fluid", "style", "InputMaskStyle", "provide", "$pcInputMask", "$parentInstance", "script", "BaseInputMask", "inheritAttrs", "emits", "inject", "$pcFluid", "data", "currentVal", "watch", "newMask", "oldMask", "initMask", "mounted", "updated", "isValueUpdated", "updateValue", "methods", "onInput", "event", "isComposing", "androidChrome", "handleAndroidInput", "handleInputChange", "updateModelValue", "target", "value", "onFocus", "_this", "focus", "clearTimeout", "caretTimeoutId", "pos", "focusText", "$el", "checkVal", "setTimeout", "document", "activeElement", "writeBuffer", "replace", "length", "caret", "$emit", "onBlur", "e", "createEvent", "initEvent", "dispatchEvent", "onKeyDown", "k", "code", "begin", "end", "iPhone", "test", "getUserAgent", "oldVal", "seekPrev", "seekNext", "clearBuffer", "shiftL", "preventDefault", "blur", "onKeyPress", "_this2", "p", "c", "next", "completed", "ctrlKey", "altKey", "metaKey", "shiftKey", "key", "len", "tests", "shiftR", "buffer", "proxy", "lastRequiredNonMaskPos", "isCompleted", "onPaste", "first", "last", "range", "offsetParent", "setSelectionRange", "collapse", "moveEnd", "moveStart", "select", "selectionStart", "selectionEnd", "createRange", "duplicate", "text", "i", "firstNonMaskPos", "getPlaceholder", "charAt", "j", "Math", "max", "t", "curVal", "start", "join", "allow", "isValueChecked", "lastMatch", "partialPosition", "defaultBuffer", "substring", "isPasteEvent", "getUnmaskedValue", "unmaskedBuffer", "push", "val", "_this3", "updateModel", "arguments", "undefined", "defs", "a", "ua", "maskTokens", "split", "RegExp", "computed", "filled", "toString", "inputClass", "cx", "rootPTOptions", "root", "mergeProps", "ptm", "ptmParams", "ptmi", "context", "hasFluid", "isEmpty", "components", "InputText", "_createBlock", "_component_InputText", "_ctx", "$data", "$options", "unstyled", "onCompositionend", "onKeydown", "onKeypress", "pt"]
}
